<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾ç‰‡&æ–‡å­—åƒç´ åŒ–è½¬æ¢å™¨</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .upload-section {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            background: #fafafa;
        }
        
        .upload-section.dragover {
            border-color: #144eb9;
            background: #f0f4ff;
        }
        
        .file-input {
            display: none;
        }
        
        .upload-btn {
            background-color: #144eb9;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        .upload-btn:hover {
            background-color: #0f3d9e;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        
        .control-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #144eb9;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #144eb9;
            cursor: pointer;
            border: none;
        }

        .slider-value {
            display: inline-block;
            background: #144eb9;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-left: 10px;
        }

        .stats {
            background: #e8f4fd;
            border: 1px solid #b8daff;
            border-radius: 6px;
            padding: 15px;
            margin: 20px 0;
            font-family: monospace;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 18px;
            font-weight: bold;
            color: #144eb9;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        .effect-demo {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
        }

        .pixel-grid {
            display: inline-block;
            margin: 0 10px;
        }

        .pixel-block {
            width: 8px;
            height: 8px;
            display: inline-block;
            border: 1px solid #ccc;
            margin: 1px;
        }

        .demo-arrow {
            font-size: 20px;
            color: #144eb9;
            margin: 0 15px;
        }
        
        .preview-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }
        
        .preview-box {
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        
        .preview-header {
            background: #f8f9fa;
            padding: 15px;
            font-weight: bold;
            color: #555;
            border-bottom: 1px solid #ddd;
        }
        
        .preview-content {
            padding: 20px;
            text-align: center;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border: 1px solid #eee;
            image-rendering: pixelated;
        }
        
        .process-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            width: 100%;
            margin-bottom: 20px;
        }
        
        .process-btn:hover {
            background-color: #218838;
        }
        
        .process-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .info {
            background: #e7f3ff;
            border: 1px solid #b3d7ff;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #0066cc;
        }
        
        .error {
            background: #ffe7e7;
            border: 1px solid #ffb3b3;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #cc0000;
        }
        
        .status {
            text-align: center;
            margin: 20px 0;
            font-style: italic;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>å›¾ç‰‡&æ–‡å­—åƒç´ åŒ–è½¬æ¢å™¨</h1>
        
        <div class="upload-section" id="uploadSection">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start;">
                <div style="text-align: center;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">ğŸ“· å›¾ç‰‡åƒç´ åŒ–</h3>
                    <input type="file" id="fileInput" class="file-input" accept="image/png,image/jpeg,image/webp,image/bmp,image/gif">
                    <button class="upload-btn" onclick="document.getElementById('fileInput').click()">é€‰æ‹©å›¾ç‰‡æ–‡ä»¶</button>
                    <p style="margin: 10px 0 5px 0;">æˆ–æ‹–æ‹½å›¾ç‰‡æ–‡ä»¶åˆ°æ­¤å¤„</p>
                    <p><small>æ”¯æŒ PNG, JPEG, WebP, BMP, GIF æ ¼å¼</small></p>
                </div>
                
                <div style="text-align: center;">
                    <h3 style="margin: 0 0 15px 0; color: #333;">âœï¸ æ–‡å­—åƒç´ åŒ–</h3>
                    <input type="text" id="textInput" placeholder="è¾“å…¥è¦åƒç´ åŒ–çš„æ–‡å­—" style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; margin-bottom: 10px;" oninput="previewText()">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <select id="textFont" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;" onchange="previewText()">
                            <option value="Arial">Arial</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Helvetica">Helvetica</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Verdana">Verdana</option>
                            <option value="Comic Sans MS">Comic Sans MS</option>
                        </select>
                        <input type="number" id="textSize" value="48" min="20" max="200" placeholder="å­—ä½“å¤§å°" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;" oninput="previewText()">
                    </div>
                    <div id="textPreview" style="min-height: 60px; border: 1px dashed #ddd; border-radius: 4px; padding: 10px; margin-bottom: 10px; background: #f9f9f9; display: flex; align-items: center; justify-content: center;">
                        <span style="color: #999; font-style: italic;">è¾“å…¥æ–‡å­—æŸ¥çœ‹é¢„è§ˆ</span>
                    </div>
                    <button class="upload-btn" onclick="generateTextImage()">ç”Ÿæˆå¹¶åƒç´ åŒ–</button>
                    <p><small>æ”¯æŒä¸­è‹±æ–‡ã€æ•°å­—ã€ç¬¦å·</small></p>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>åƒç´ åŒ–å¼ºåº¦ (å¿«é€Ÿè°ƒèŠ‚):</label>
                <div class="slider-container">
                    <input type="range" id="pixelationSlider" class="slider" min="1" max="50" value="10" oninput="updatePixelationPreview()">
                    <span class="slider-value" id="sliderValue">10x</span>
                </div>
                <small style="color: #666;">
                    æ‹–åŠ¨æ»‘å—å®æ—¶é¢„è§ˆæ•ˆæœ<br>
                    â€¢ 1x = åŸå›¾ä¸å˜ â€¢ 10x = é€‚ä¸­æ•ˆæœ â€¢ 50x = æåº¦åƒç´ åŒ–
                </small>
            </div>
            <div class="control-group">
                <label>é«˜çº§è®¾ç½® (ç‹¬ç«‹æ§åˆ¶XYè½´):</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div>
                        <label style="font-size: 12px;">Xè½´å€æ•° (å®½åº¦å‹ç¼©):</label>
                        <input type="number" id="pixelationX" value="10" min="1" max="100" onchange="updatePixelationPreview()">
                    </div>
                    <div>
                        <label style="font-size: 12px;">Yè½´å€æ•° (é«˜åº¦å‹ç¼©):</label>
                        <input type="number" id="pixelationY" value="10" min="1" max="100" onchange="updatePixelationPreview()">
                    </div>
                </div>
                <small style="color: #666;">
                    â€¢ Xè½´=5, Yè½´=10 â†’ æ¨ªå‘5åƒç´ ã€çºµå‘10åƒç´ åˆå¹¶ä¸º1åƒç´ <br>
                    â€¢ ä¸åŒXYå€¼å¯åˆ›é€ æ‹‰ä¼¸æ•ˆæœ
                </small>
                
                <div class="effect-demo" id="effectDemo">
                    <div style="margin-bottom: 10px; font-weight: bold; color: #333;">åƒç´ åŒ–åŸç†æ¼”ç¤º</div>
                    <div id="pixelDemoContent">é€‰æ‹©å›¾ç‰‡åæŸ¥çœ‹å®æ—¶æ¼”ç¤º</div>
                </div>
            </div>
        </div>

        <div class="stats" id="imageStats" style="display: none;">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-number" id="originalPixels">0</div>
                    <div class="stat-label">åŸå§‹åƒç´ </div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="pixelatedPixels">0</div>
                    <div class="stat-label">åƒç´ åŒ–å</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="compressionRatio">0x</div>
                    <div class="stat-label">å‹ç¼©æ¯”</div>
                </div>
                <div class="stat-item">
                    <div class="stat-number" id="reductionPercent">0%</div>
                    <div class="stat-label">å‡å°‘æ¯”ä¾‹</div>
                </div>
            </div>
        </div>
        
        <button class="process-btn" id="processBtn" disabled onclick="processImage()">å¼€å§‹åƒç´ åŒ–è½¬æ¢</button>
        
        <div class="status" id="status"></div>
        
        <div class="preview-section">
            <div class="preview-box">
                <div class="preview-header">åŸå›¾é¢„è§ˆ</div>
                <div class="preview-content" id="originalPreview">
                    <span style="color: #999;">è¯·å…ˆé€‰æ‹©å›¾ç‰‡æ–‡ä»¶</span>
                </div>
            </div>
            
            <div class="preview-box">
                <div class="preview-header">åƒç´ åŒ–æ•ˆæœé¢„è§ˆ</div>
                <div class="preview-content" id="pixelatedPreview">
                    <span style="color: #999;">ç­‰å¾…å¤„ç†...</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentFile = null;
        let originalBitmap = null;
        let isTextMode = false;

        // æ‹–æ‹½åŠŸèƒ½
        const uploadSection = document.getElementById('uploadSection');
        const fileInput = document.getElementById('fileInput');
        const processBtn = document.getElementById('processBtn');
        const status = document.getElementById('status');

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            const validTypes = ['image/png', 'image/jpeg', 'image/webp', 'image/bmp', 'image/gif'];
            if (!validTypes.includes(file.type)) {
                alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶æ ¼å¼ï¼');
                return;
            }

            currentFile = file;
            processBtn.disabled = false;
            
            // åˆ›å»ºImageBitmapç”¨äºå®æ—¶é¢„è§ˆ
            originalBitmap = await createImageBitmap(file);
            
            // æ˜¾ç¤ºåŸå›¾é¢„è§ˆ
            const reader = new FileReader();
            reader.onload = (e) => {
                const originalPreview = document.getElementById('originalPreview');
                originalPreview.innerHTML = `
                    <img src="${e.target.result}" class="preview-image" alt="åŸå›¾é¢„è§ˆ">
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        æ–‡ä»¶å: ${file.name}<br>
                        å¤§å°: ${(file.size / 1024).toFixed(2)} KB<br>
                        å°ºå¯¸: ${originalBitmap.width} Ã— ${originalBitmap.height}
                    </div>
                `;
                
                // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                document.getElementById('imageStats').style.display = 'block';
                updateImageStats();
                
                // ç«‹å³æ˜¾ç¤ºåƒç´ åŒ–é¢„è§ˆ
                updatePixelationPreview();
            };
            reader.readAsDataURL(file);
            
            status.textContent = `å·²é€‰æ‹©æ–‡ä»¶: ${file.name}`;
            isTextMode = false;
        }

        async function generateTextImage() {
            const text = document.getElementById('textInput').value.trim();
            const font = document.getElementById('textFont').value;
            const fontSize = parseInt(document.getElementById('textSize').value);
            
            if (!text) {
                alert('è¯·è¾“å…¥è¦åƒç´ åŒ–çš„æ–‡å­—ï¼');
                return;
            }
            
            // åˆ›å»ºä¸´æ—¶canvasæ¥æ¸²æŸ“æ–‡å­—
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®å­—ä½“
            ctx.font = `${fontSize}px "${font}"`;
            ctx.fillStyle = '#333333';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // æµ‹é‡æ–‡å­—å°ºå¯¸
            const metrics = ctx.measureText(text);
            const textWidth = Math.ceil(metrics.width);
            const textHeight = Math.ceil(fontSize * 1.2); // ç»™æ–‡å­—ç•™ä¸€äº›ä¸Šä¸‹ç©ºé—´
            
            // è®¾ç½®canvaså°ºå¯¸
            canvas.width = textWidth + 40; // å·¦å³å„ç•™20pxè¾¹è·
            canvas.height = textHeight + 40; // ä¸Šä¸‹å„ç•™20pxè¾¹è·
            
            // é‡æ–°è®¾ç½®å­—ä½“ï¼ˆcanvaså°ºå¯¸æ”¹å˜åéœ€è¦é‡æ–°è®¾ç½®ï¼‰
            ctx.font = `${fontSize}px "${font}"`;
            ctx.fillStyle = '#333333';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // å¡«å……ç™½è‰²èƒŒæ™¯
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillStyle = '#333333';
            ctx.fillText(text, 20, 20);
            
            // è½¬æ¢ä¸ºImageBitmap
            originalBitmap = await createImageBitmap(canvas);
            currentFile = null;
            isTextMode = true;
            processBtn.disabled = false;
            
            // æ˜¾ç¤ºåŸå›¾é¢„è§ˆ
            const originalPreview = document.getElementById('originalPreview');
            originalPreview.innerHTML = `
                <canvas class="preview-image" width="${canvas.width}" height="${canvas.height}" style="border: 1px solid #eee;"></canvas>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    æ–‡å­—å†…å®¹: "${text}"<br>
                    å­—ä½“: ${font} ${fontSize}px<br>
                    å°ºå¯¸: ${canvas.width} Ã— ${canvas.height}
                </div>
            `;
            
            const previewCanvas = originalPreview.querySelector('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.drawImage(canvas, 0, 0);
            
            // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
            document.getElementById('imageStats').style.display = 'block';
            updateImageStats();
            
            // ç«‹å³æ˜¾ç¤ºåƒç´ åŒ–é¢„è§ˆ
            updatePixelationPreview();
            
            status.textContent = `å·²ç”Ÿæˆæ–‡å­—å›¾ç‰‡: "${text}"`;
        }

        function previewText() {
            const text = document.getElementById('textInput').value.trim();
            const font = document.getElementById('textFont').value;
            const fontSize = parseInt(document.getElementById('textSize').value) || 48;
            const preview = document.getElementById('textPreview');
            
            if (!text) {
                preview.innerHTML = '<span style="color: #999; font-style: italic;">è¾“å…¥æ–‡å­—æŸ¥çœ‹é¢„è§ˆ</span>';
                return;
            }
            
            // è®¡ç®—åˆé€‚çš„é¢„è§ˆå­—ä½“å¤§å°ï¼ˆæœ€å¤§30pxï¼‰
            const previewSize = Math.min(fontSize * 0.6, 30);
            
            preview.innerHTML = `
                <div style="font-family: '${font}'; font-size: ${previewSize}px; color: #333; text-align: center; line-height: 1.2;">
                    ${text}
                </div>
            `;
        }

        function updateSliderValue() {
            const slider = document.getElementById('pixelationSlider');
            const pixelationX = document.getElementById('pixelationX');
            const pixelationY = document.getElementById('pixelationY');
            const sliderValue = document.getElementById('sliderValue');
            
            const value = slider.value;
            sliderValue.textContent = value + 'x';
            pixelationX.value = value;
            pixelationY.value = value;
        }

        async function updatePixelationPreview() {
            if (!originalBitmap) return;
            
            const slider = document.getElementById('pixelationSlider');
            const pixelationX = document.getElementById('pixelationX');
            const pixelationY = document.getElementById('pixelationY');
            
            // åŒæ­¥æ»‘å—å’Œè¾“å…¥æ¡†
            if (document.activeElement === slider) {
                updateSliderValue();
            }
            
            const xValue = parseInt(pixelationX.value);
            const yValue = parseInt(pixelationY.value);
            
            try {
                // åº”ç”¨åƒç´ åŒ–
                const pixelatedBitmap = await applyPixelation(originalBitmap, xValue, yValue);
                
                // æ›´æ–°é¢„è§ˆ
                displayPixelatedPreview(pixelatedBitmap, xValue, yValue);
                
                // æ›´æ–°ç»Ÿè®¡
                updateImageStats(pixelatedBitmap.width * pixelatedBitmap.height);
                
            } catch (error) {
                console.error('å®æ—¶é¢„è§ˆå‡ºé”™:', error);
            }
        }

        function displayPixelatedPreview(pixelatedBitmap, pixelationX, pixelationY) {
            const pixelatedPreview = document.getElementById('pixelatedPreview');
            
            // è®¡ç®—æ˜¾ç¤ºå°ºå¯¸
            const maxDisplaySize = 400;
            const scale = Math.min(maxDisplaySize / pixelatedBitmap.width, maxDisplaySize / pixelatedBitmap.height);
            const displayWidth = Math.floor(pixelatedBitmap.width * scale);
            const displayHeight = Math.floor(pixelatedBitmap.height * scale);
            
            pixelatedPreview.innerHTML = `
                <canvas width="${displayWidth}" height="${displayHeight}" 
                        class="preview-image" style="border: 1px solid #eee; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;"></canvas>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    åƒç´ åŒ–å°ºå¯¸: ${pixelatedBitmap.width} Ã— ${pixelatedBitmap.height}<br>
                    åƒç´ åŒ–å€æ•°: ${pixelationX} Ã— ${pixelationY}
                </div>
            `;
            
            const previewCanvas = pixelatedPreview.querySelector('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            previewCtx.imageSmoothingEnabled = false;
            previewCtx.drawImage(pixelatedBitmap, 0, 0, displayWidth, displayHeight);
        }

        function updateImageStats(pixelatedPixelCount = null) {
            if (!originalBitmap) return;
            
            const originalPixelCount = originalBitmap.width * originalBitmap.height;
            
            // è®¡ç®—å½“å‰è®¾ç½®ä¸‹çš„åƒç´ åŒ–ç»“æœ
            if (pixelatedPixelCount === null) {
                const pixelationX = parseInt(document.getElementById('pixelationX').value);
                const pixelationY = parseInt(document.getElementById('pixelationY').value);
                const newWidth = Math.ceil(originalBitmap.width / pixelationX);
                const newHeight = Math.ceil(originalBitmap.height / pixelationY);
                pixelatedPixelCount = newWidth * newHeight;
            }
            
            const compressionRatio = originalPixelCount / pixelatedPixelCount;
            const reductionPercent = ((originalPixelCount - pixelatedPixelCount) / originalPixelCount * 100);
            
            // æ ¼å¼åŒ–æ•°å­—æ˜¾ç¤º
            document.getElementById('originalPixels').textContent = originalPixelCount.toLocaleString();
            document.getElementById('pixelatedPixels').textContent = pixelatedPixelCount.toLocaleString();
            document.getElementById('compressionRatio').textContent = compressionRatio.toFixed(1) + 'x';
            document.getElementById('reductionPercent').textContent = reductionPercent.toFixed(1) + '%';
            
            // æ›´æ–°åŸç†æ¼”ç¤º
            updatePixelDemo();
        }

        function updatePixelDemo() {
            const pixelationX = parseInt(document.getElementById('pixelationX').value);
            const pixelationY = parseInt(document.getElementById('pixelationY').value);
            const demoContent = document.getElementById('pixelDemoContent');
            
            if (!originalBitmap) {
                demoContent.innerHTML = 'é€‰æ‹©å›¾ç‰‡åæŸ¥çœ‹å®æ—¶æ¼”ç¤º';
                return;
            }
            
            // è®¡ç®—å®é™…å°ºå¯¸å˜åŒ–
            const originalWidth = originalBitmap.width;
            const originalHeight = originalBitmap.height;
            const newWidth = Math.ceil(originalWidth / pixelationX);
            const newHeight = Math.ceil(originalHeight / pixelationY);
            
            demoContent.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; flex-wrap: wrap;">
                    <div style="text-align: center; margin: 10px;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">åŸå§‹åƒç´ å—</div>
                        <div style="border: 2px solid #28a745; padding: 5px; display: inline-block;">
                            ${createPixelGrid(pixelationX, pixelationY, '#e3f2fd')}
                        </div>
                        <div style="font-size: 11px; margin-top: 3px;">${pixelationX}Ã—${pixelationY} = ${pixelationX * pixelationY}åƒç´ </div>
                    </div>
                    
                    <div class="demo-arrow">â†’</div>
                    
                    <div style="text-align: center; margin: 10px;">
                        <div style="font-size: 12px; color: #666; margin-bottom: 5px;">åˆå¹¶å</div>
                        <div style="border: 2px solid #144eb9; padding: 5px; display: inline-block;">
                            ${createPixelGrid(1, 1, '#144eb9')}
                        </div>
                        <div style="font-size: 11px; margin-top: 3px;">1åƒç´ (å¹³å‡è‰²)</div>
                    </div>
                </div>
                
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 12px;">
                    <strong>å°ºå¯¸å˜åŒ–:</strong> ${originalWidth}Ã—${originalHeight} â†’ ${newWidth}Ã—${newHeight}<br>
                    <strong>å¤„ç†æ–¹å¼:</strong> æ¯${pixelationX}Ã—${pixelationY}ä¸ªåƒç´ åˆå¹¶æˆ1ä¸ªåƒç´ 
                </div>
            `;
        }

        function createPixelGrid(width, height, color) {
            let grid = '';
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    grid += `<div class="pixel-block" style="background-color: ${color};"></div>`;
                }
                if (y < height - 1) grid += '<br>';
            }
            return grid;
        }

        async function processImage() {
            if (!originalBitmap) {
                alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼');
                return;
            }
            
            // ç”±äºå·²ç»æœ‰å®æ—¶é¢„è§ˆï¼Œè¿™é‡Œåªæ˜¯æ›´æ–°çŠ¶æ€
            status.textContent = 'åƒç´ åŒ–è½¬æ¢å®Œæˆï¼å¯ä»¥è°ƒèŠ‚æ»‘å—æŸ¥çœ‹ä¸åŒæ•ˆæœ';
        }

        // åƒç´ åŒ–å¤„ç†å‡½æ•°ï¼ŒåŸºäºcontent.jsçš„å®ç°
        async function applyPixelation(originalBitmap, pixelationX, pixelationY) {
            console.log(`åº”ç”¨ ${pixelationX}x${pixelationY} åƒç´ åŒ–...`);
            
            const originalWidth = originalBitmap.width;
            const originalHeight = originalBitmap.height;
            const newWidth = Math.ceil(originalWidth / pixelationX);
            const newHeight = Math.ceil(originalHeight / pixelationY);

            // åˆ›å»ºæºç”»å¸ƒ
            const sourceCanvas = new OffscreenCanvas(originalWidth, originalHeight);
            const sourceCtx = sourceCanvas.getContext('2d', { willReadFrequently: true });
            sourceCtx.imageSmoothingEnabled = false;
            sourceCtx.drawImage(originalBitmap, 0, 0);

            // åˆ›å»ºç›®æ ‡ç”»å¸ƒ
            const targetCanvas = new OffscreenCanvas(newWidth, newHeight);
            const targetCtx = targetCanvas.getContext('2d', { willReadFrequently: true });
            targetCtx.imageSmoothingEnabled = false;

            const sourceImageData = sourceCtx.getImageData(0, 0, originalWidth, originalHeight);
            const targetImageData = targetCtx.createImageData(newWidth, newHeight);

            // å¯¹æ¯ä¸ªåƒç´ åŒ–å—è¿›è¡Œå¤„ç†
            for (let py = 0; py < newHeight; py++) {
                for (let px = 0; px < newWidth; px++) {
                    const startX = px * pixelationX;
                    const startY = py * pixelationY;
                    const endX = Math.min(startX + pixelationX, originalWidth);
                    const endY = Math.min(startY + pixelationY, originalHeight);

                    let totalR = 0, totalG = 0, totalB = 0, totalA = 0;
                    let pixelCount = 0;

                    // è®¡ç®—å—å†…æ‰€æœ‰åƒç´ çš„å¹³å‡å€¼
                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            const sourceIndex = (y * originalWidth + x) * 4;
                            if (sourceImageData.data[sourceIndex + 3] > 0) { // åªå¤„ç†éé€æ˜åƒç´ 
                                totalR += sourceImageData.data[sourceIndex];
                                totalG += sourceImageData.data[sourceIndex + 1];
                                totalB += sourceImageData.data[sourceIndex + 2];
                                totalA += sourceImageData.data[sourceIndex + 3];
                                pixelCount++;
                            }
                        }
                    }

                    // è®¾ç½®ç›®æ ‡åƒç´ 
                    if (pixelCount > 0) {
                        const avgR = Math.round(totalR / pixelCount);
                        const avgG = Math.round(totalG / pixelCount);
                        const avgB = Math.round(totalB / pixelCount);
                        const avgA = Math.round(totalA / pixelCount);

                        const targetIndex = (py * newWidth + px) * 4;
                        targetImageData.data[targetIndex] = avgR;
                        targetImageData.data[targetIndex + 1] = avgG;
                        targetImageData.data[targetIndex + 2] = avgB;
                        targetImageData.data[targetIndex + 3] = avgA;
                    }
                }
            }

            targetCtx.putImageData(targetImageData, 0, 0);
            return await createImageBitmap(targetCanvas);
        }
    </script>
</body>
</html>